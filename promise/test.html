<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>简易版本 promise </title>
</head>
<body>
    <script>
        function MyPromise(fn) {
            var promise = this;
            promise._resolves = [];
            promise._rejects = [];
            promise._status = 'PENDING';
            promise._reason = null;
            promise._value = null;
    
            this.then = function(onFulfilled, onRejected) {
    
                return new MyPromise(function(resolve, reject) { // 因为返回类型都是Promise 所以链式操作依然有效
                    function handle(value) {    //对上一个 promise 的 then 中回调进行了处理，并且调用了当前的 promise 中的 resolve 方法
                        var ret = isFunction(onFulfilled) && onFulfilled(value) || value; 
    
                        if (ret && typeof ret['then'] == 'function') { // then里面函数 对Promise对象处理 如果是则调用then 形成嵌套
    
                            ret.then(function(value) {
                                resolve(value); // 同时then方法中调用resolve 链式得以维持
                            })
                        } else {
                            resolve(ret);
                        }
                    }
    
                    function errback(reason) {
                        reason = isFunction(onRejected) && onRejected(reason) || reason;
                        reject(reason);
                    }
    
                    if (promise._status == 'PENDING') {
                        promise._resolves.push(handle);
                        promise._rejects.push(errback);
                    } else if (promise._status == 'FULFILLED') {
                        handle(promise._value);
                    } else if (promise._status == 'REJECTED') {
                        errback(promise._reason);
                    }
                })
    
            };
    
    
            function isFunction(func) {
                if (typeof func == 'function') {
                    return true
                } else {
                    return false
                }
            }
    
            function resolve(value) {
                // console.log('length', promise._resolves.length);
                setTimeout(function() { // resolve 执行时 可能 _resolve里还没填入回调 比如传入一个不包含异步操作的函数
                    promise._status = "FULFILLED";
                    promise._resolves.forEach(function(callback) {
                        callback(value);
                    });
                }, 0);
    
            }
    
            function reject(value) {
                setTimeout(function() {
                    promise._status = "REJECTED";
                    promise._rejects.forEach(function(callback) {
                        promise._reason = callback(value);
                    })
                }, 0);
            }
    
            fn(resolve);
        }
    </script>
    <script>
        // 正常的promise
        function fn1(resolve, reject) {
            console.log('步骤一：执行');
            resolve('1');
            console.log('5')
            setTimeout(function() {
                console.log('2')
            }, 0);
        }

        function fn2(resolve, reject) {
            console.log('步骤二：执行');
            resolve('3')
            setTimeout(function() {
                console.log('4');
            }, 1000);
        }

        new Promise(fn1).then(function(val) {
            console.log(val);
            return new Promise(fn2);
        }).then(function(val) {
            console.log(val);
            return 33;
        }).then(function(val) {
            console.log(val);
        });
    </script>
</body>
</html>